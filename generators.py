import numpy as np
import networkx as nx

from collections import Counter
from typing import List

from utils import compare_graphs


def get_ranking(n: int, g: nx.Graph) -> List[int]:
    """
    Generates a ranking of target nodes for a given node

    :param n: node for which ranking is generated
    :param g: input network
    :returns a list of nodes selected as targets for the node n
    """
    nodes = [i for i in g.nodes if i != n]
    np.random.shuffle(nodes)

    return nodes


def get_ranking_probs(n: int) -> List[float]:
    """
    Generates the list of probabilities for a given length of ranking

    :param n: length of the ranking
    :returns a list of diminishing probabilities
    """
    ranks = [ 1/i for i in range(1, n+1) ]

    return [ r/sum(ranks) for r in ranks]


def generate_network(g: nx.Graph) -> nx.Graph:
    """
    Generates a network based on the empirical input network

    :param g: input network
    :returns artificial network generated by the priority attachment mechanism
    """

    result = nx.Graph()
    result.add_nodes_from(g.nodes)

    num_nodes = g.number_of_nodes()
    degree_sequence = sorted([d for n,d in g.degree()])
    degree_count = Counter(degree_sequence)
    deg, cnt = zip(*degree_count.items())

    degree_probs = [c/sum(cnt) for c in cnt]

    for i in range(num_nodes):
        num_edges = np.random.choice(a=deg, p=degree_probs)
        node_ranking = get_ranking(i, g)
        node_probs = get_ranking_probs(len(node_ranking))
        target_nodes = np.random.choice(a=node_ranking, p=node_probs, size=num_edges, replace=False)

        for j in target_nodes:
            result.add_edge(i, j)

    return result


if __name__ == '__main__':

    g = nx.erdos_renyi_graph(n=120, p=0.1)

    graphs = []

    for i in range(10):
        graphs.append(generate_network(g))

    for k,v in compare_graphs(g, graphs).items():
        print(k, v)